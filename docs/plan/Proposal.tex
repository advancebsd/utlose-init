\documentclass{article}

\usepackage[margin=0.75in]{geometry}
\usepackage[style=numeric-comp, sorting=none, backend=biber, doi=false, isbn=false, url=false]{biblatex}
\usepackage{minted}
\setminted{autogobble}
\newcommand*{\bibtitle}{Bibliography}

\addbibresource{Proposal.bib}

\title{Init System Proposal\\ \large{For all posix complient systems}}
\author{James Hobson and Michael Reim}

\begin{document}
\maketitle

\tableofcontents

\setlength{\parindent}{0em}
\setlength{\parskip}{1em}

\section{Motivations}
Proposing new init systems and service management systems in 2021 is surprisingly still a taboo
topic. The space has seen little innovation since the controversially wide adoption of systemd
in linux and I think, rather understandably, no one wants second init world war. But the
war never really ended; more systemd gained control of vast amounts of territory and a cease
fire was put in place. There still exists a minority who feel oppressed and jumped over to
the BSDs to escape the creep of systemd. But this leaves the BSDs in a situation where,
if they wanted to innovate their init system and service management, they would have
to tried carefully to avoid emoting any PTSD in the refugees they got from linux. These
small open source communities are too small to fragment and so an unspoken policy of 
init-system complacency has been adopted.

But things are changing. DragonflyBSD has gone from a relatively unknown operating
system to one that has started to out perform linux in benchmarks\footfullcite{dfbsd-phoronix}.
One thing that systemd has shown us is that service management is key to speed and
resource management and so it may be time to take another look at init systems and service
management so that the BSDs have an up-to-date answer to the systemd problem and
so that systemd has competition in it's domain.

\section{Other Software in the Domain}
\subsection{Old Unix RC}
\nocite{unix-ii}
The old unix RC was extremely primitive. A benefit to this approach is that it's very stable,
but the completely lack of service management caused issues. Some software, such as
appache HTTPd, came with management shell scripts\footfullcite{app-service}, but
for those that didn't, your only option was to send the correct signal to the process
via \texttt{kill}. For admins unfamiliar with this kind of management it's in fact easier to
restart the whole machine after some service died than to figure out how to start it again!

\subsection{BSD rc}
BSD innovated by adding \texttt{rc.local}. This separated system init and user specified
init, thus removing the anxiety sysadmins would face each time they needed to update the
system. Apart from that change, it was pretty much the same as old Unix init\footfullcite[Research Unix-style/BSD-style]{wiki-init}
and so inherited the lack of features with respect to service management.


\subsection{SysV init}
SysV init added the concept of runlevels\footfullcite[SysV-Style]{wiki-init} and basic 
service management\footfullcite{man-service}. A run level is a defined state that includes
a set of services which have to be running (or have to not be running). Changing run level
is a simple as stopping the services that require stopping and starting the ones
that are not running. The issue with SysV-style init is it's implementation and
how basic the service management is. It over uses symlinks in the file system to determine order,
it uses PID files to keep track of processes. On top of this, the service management is
quite primitive.

\subsection{BSD rc.d}
It provides the main benefit of breaking up formerly monolithic rc into several
init scripts. Unlike SysV init, it is configured centrally in a single (from the user
perspective) file: rc.conf. It also features the \texttt{rcorder(8)} tool and can generally
figure out itself what the right order to start services in is. Thus it avoids the most
serious problems with SysV init. But it's somewhat limited;
there is no service supervision, service status is not actually reliable and it's not helpful
to get a full system overview. Parallelism is an afterthought and a somewhat recent feature
addition.

\subsection{OpenRC}
Good: Introduces some convenience functions like rc-status. Was conceived with allowing
for parallelism. It can work together with other programs to allow for service supervision.
Bad: Picked up the SysV folly of service enabling via symlinks. It is still unreliable with
service status. By itself it's not able to supervise services.

\subsection{Upstart}
Good: Compatibility with SysV init scripts. Asynchronous, event-driven nature. Service
supervision. Bad: Hm! It's been a while\dots I don't remember off the top of my head what I
disliked. Would need to look into it again.

\subsection{Systemd}
Good: Transition from init scripts to unit files. Service supervision. Bad: Braindead
feature creep (for a PID 1 process!!). Very strange random defects (= unreliable). There's
much more both for good and bad, but these are the main 4 points about systemd for me.

\section{Proposal}
The aims of this project is to write a research init system. It will provide
two things: A way to start services and a way to monitor and manage them.
These components have the following aims
\begin{itemize}
    \item To abstract away order and state from the system
    \item To start the minimum possible number of services
    \item To be as parallel as possible
    \item To assist the user at every complexity level
    \item To allow for maximum customisability
    \item To be fail-safe. If PID 1 crashes, \textit{hopefully}, it will not require a reboot.
    \item To be POSIX compliant as flexible with licensing as to not lock ourselves to a particular operating system
\end{itemize}

Unix has a long history of using programming language theory to solve problems. As soon as
lex and yacc, were available, tools such as awk were written. In the case of awk, a language
for text processing and report generation was written. The language abstracts away all that
gets in the way of it's aims so that it can do what it does well. This is in contrast to most
of the available init systems, which tend to be build upon pre-existing technologies (such
as shell and the file system) or use extremely generic configuration formats (systemd uses
the ini format). As a result, very little complexity is abstracted away. We propose a
new language designed for service management.

The first idea for this language is that dependencies are captured in the syntax. The next idea
is that the language is lazily evaluated. This means that everything is started as late as possible
(if started at all). Automatic parallelism and lazy service starting should mean lighting fast
boot times and minimum resource usage. The language will be garbage collected. But what is
the garbage? The garbage is services that are currently not in use. Will maintain minimum
resource usage.

The language will also allow for other interpreters to be used in the definition of
services. If you have a bunch of complex procedures that need to be run to calculate how a service
must start, then you can use haskell, lua python (etc). Or you can keep it simple and let it
default to shell.

We may explore disowning children processes. This has some limitations, but possibly would allow
the daemon to fail without the system being rendered unusable.

\subsection{Architecture}
\subsection{Configuration Language}
\subsection{Service Management Tool}

\setlength{\baselineskip}{0pt} % JEM: Single-space References

{\renewcommand*\MakeUppercase[1]{#1}%
\printbibliography[heading=bibintoc,title={\bibtitle}]}

\end{document}
