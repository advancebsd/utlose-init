\documentclass{article}

\usepackage[margin=0.75in]{geometry}
\usepackage[style=numeric-comp, sorting=none, backend=biber, doi=false, isbn=false, url=false]{biblatex}
\usepackage{minted}
\setminted{autogobble}
\newcommand*{\bibtitle}{Bibliography}

\addbibresource{Proposal.bib}

\title{Init System Proposal\\ \large{For all posix complient systems}}
\author{James Hobson and Michael Reim}

\begin{document}
\maketitle

\tableofcontents

\setlength{\parindent}{0em}
\setlength{\parskip}{1em}

\section{Motivations}
Proposing new init systems and service management systems in 2022 is surprisingly still a taboo topic. This space has seen little innovation since the controversially wide adoption of \texttt{systemd} in linux and I think, rather understandably, no one wants another\footnote{The systemd case may be what many people immediately think off as it kind of still rages on. It is however not the first fierce fight over init systems. In fact it feels a lot like the situation when the BSDs adopted \texttt{rc.d}. There have been fierce arguments including claims of this being "not the BSD way" and threads to fork the old init system and continue on with it! For some reason or another, people tend to be extremely touchy when it comes to their \texttt{init} - and probably rightfully so!} init world war. But the war never really ended; while \texttt{systemd} gained control of vast amounts of territory\footnote{Some people claim that this happened not due to technical superiority. There is some truth to that and especially in the fight over \textit{Debian} corporate actors (\textit{Red Hat} for \texttt{systemd} and \textit{Canonical} in favor of \texttt{upstart}) were not hard to spot. But it is also true that \texttt{systemd} \textit{does} provide a lot of value over \texttt{SysV init}.} and a kind of cease fire was put in place.

Despite having lost all the mainstream Linux distributions to systemd, enough people continue their resistance to make maintaining several alternative distributions feasible.\footnote{There are those like \textit{Slackware} which has used its BSD-inspired init system before \texttt{systemd} entered the stage and continues to do so. Other such examples are \textit{Gentoo} (by default) and \textit{Alpine Linux} which uses \texttt{openRC} and \textit{Void Linux} that adopted \texttt{runit}. There are however even new \textit{systemd-free} distributions which consider this an important feature. Notable xamples are the Debian fork \textit{Devuan} and the Arch Linux fork \textit{Artix}.} However there also exists a minority who still felt oppressed and jumped over to the BSDs to escape the creep of systemd. But this leaves the BSDs in a situation where, if they wanted to innovate their init system and service management, they would have to to try and carefully avoid emoting any PTSD in the refugees they got from Linux. These non-mainstream open source communities are likely too small to further fragment and remain viable\footnote{\textit{FreeBSD} as the by far largest player has seen several failed attempts of getting \texttt{openRC} into the base system. \textit{TrueOS}, a friendly fork that received corporate sponsorship has made completed the switch -- but it died not too long afterwards. \textit{GhostBSD}, a desktop-focused distribution of FreeBSD picked it up and maintained it for years but eventually even migrated back mainly because of the maintenance burden.}. Therefore an unspoken policy of init-system complacency has been adopted (i.e. it's regarded simple, well-known and for a lot use cases in fact \textit{good enough}).

While some people argue that GNU/Linux is the only remaining Unix-like operating system that still matters, things are changing. The last couple of years have seen renewed interest in *BSD and an increase in newcomers. \textit{FreeBSD} is attractive to many due to its superb integration of ZFS, its proven jails system and many other features. \textit{OpenBSD} is relatively well known for its security-related innovations. \textit{NetBSD} is a little less visible, but people are also finding their way to it. And even \textit{Dragonfly BSD} has gone from a relatively unknown operating system to one that has started to out perform Linux in some benchmarks\footfullcite{dfbsd-phoronix}.

However there are a few things that arguably hinder a renaissance of the BSD. One thing that \texttt{systemd} has shown is that proper service management is key to speed and effective resource management. Therefore it may be time to take another look at init systems and service management so that the BSDs can have an up-to-date answer to the systemd problem and so that systemd has competition in it's domain. There are a couple of candidates to potentially fill that gap. It makes sense to take a closer look at them first.

\section{Other Software in the Domain}
\subsection{Old Unix RC}
\nocite{unix-ii}
The old unix RC was extremely primitive. A benefit to this approach is that it's very stable,
but the completely lack of service management caused issues. Some software, such as
appache HTTPd, came with management shell scripts\footfullcite{app-service}, but
for those that didn't, your only option was to send the correct signal to the process
via \texttt{kill}. For admins unfamiliar with this kind of management it's in fact easier to
restart the whole machine after some service died than to figure out how to start it again!

\subsection{BSD rc}
BSD innovated by adding \texttt{rc.local}. This separated system init and user specified
init, thus removing the anxiety sysadmins would face each time they needed to update the
system. Apart from that change, it was pretty much the same as old Unix init\footfullcite[Research Unix-style/BSD-style]{wiki-init}
and so inherited the lack of features with respect to service management.


\subsection{SysV init}
SysV init added the concept of runlevels\footfullcite[SysV-Style]{wiki-init} and basic 
service management\footfullcite{man-service}. A run level is a defined state that includes
a set of services which have to be running (or have to not be running). Changing run level
is a simple as stopping the services that require stopping and starting the ones
that are not running. The issue with SysV-style init is it's implementation and
how basic the service management is. It over uses symlinks in the file system to determine order,
it uses PID files to keep track of processes. On top of this, the service management is
quite primitive.

\subsection{BSD rc.d}
It provides the main benefit of breaking up formerly monolithic rc into several
init scripts. Unlike SysV init, it is configured centrally in a single (from the user
perspective) file: rc.conf. It also features the \texttt{rcorder(8)} tool and can generally
figure out itself what the right order to start services in is. Thus it avoids the most
serious problems with SysV init. But it's somewhat limited;
there is no service supervision, service status is not actually reliable and it's not helpful
to get a full system overview. Parallelism is an afterthought and a somewhat recent feature
addition.

\subsection{OpenRC}
Good: Introduces some convenience functions like rc-status. Was conceived with allowing
for parallelism. It can work together with other programs to allow for service supervision.
Bad: Picked up the SysV folly of service enabling via symlinks. It is still unreliable with
service status. By itself it's not able to supervise services.

\subsection{Upstart}
Good: Compatibility with SysV init scripts. Asynchronous, event-driven nature. Service
supervision. Bad: Hm! It's been a while\dots I don't remember off the top of my head what I
disliked. Would need to look into it again.

\subsection{Systemd}
Good: Transition from init scripts to unit files. Service supervision. Bad: Braindead
feature creep (for a PID 1 process!!). Very strange random defects (= unreliable). There's
much more both for good and bad, but these are the main 4 points about systemd for me.

\section{Proposal for Utløse}
The aims of this project is to write a research init system called Utløse. It will provide
two things: A way to start services and a way to monitor and manage them.
These components have the following aims
\begin{itemize}
    \item To abstract away order and state from the system
    \item To start the minimum possible number of services
    \item To be as parallel as possible
    \item To assist the user at every complexity level
    \item To allow for maximum customisability
    \item To be fail-safe. If PID 1 crashes, \textit{hopefully}, it will not require a reboot.
    \item To be POSIX compliant and as flexible with licensing as to not lock ourselves to a particular operating system
    \item To intergrate well into package managers
    \item To allow for central monitoring and control for distributed systems
\end{itemize}

Unix has a long history of using programming language theory to solve problems. As soon as
lex and yacc, were available, tools such as awk were written. In the case of awk, a language
for text processing and report generation was written. The language abstracts away all that
gets in the way of it's aims so that it can do what it does well. This is in contrast to most
of the available init systems, which tend to be build upon pre-existing technologies (such
as shell and the file system) or use extremely generic configuration formats (systemd uses
the ini format). As a result, very little complexity is abstracted away. We propose a
new language designed for service management.

The first idea for this language is that dependencies are captured in the syntax. The next idea
is that the language is lazily evaluated. This means that everything is started as late as possible
(if started at all). Automatic parallelism and lazy service starting should mean lighting fast
boot times and minimum resource usage. The language will be garbage collected. But what is
the garbage? The garbage is services that are currently not in use. Will maintain minimum
resource usage.

The language will also allow for other interpreters to be used in the definition of
services. If you have a bunch of complex procedures that need to be run to calculate how a service
must start, then you can use haskell, lua python (etc). Or you can keep it simple and let it
default to shell.

We may explore disowning children processes. This has some limitations, but possibly would allow
the daemon to fail without the system being rendered unusable.

\subsection{Architecture}
There will be two executables:
\begin{itemize}
  \item \texttt{utlosed}
  \item \texttt{utloseadm}
\end{itemize}
Where \texttt{utlosed} will be the daemon that controls the starting and maintaining of services, and
\texttt{utloseadm} which is the frontend to be used by both users and other applications.
The two applications will be connected via ZeroMQ\footfullcite{zmq-home} sockets. There will be request and reply sockets
for control, but also publisher and subscribe sockets. These will be used for distributed logging and alarms.
ZeroMQ is a good choice because of curveZMQ\footfullcite{cmq-home}. Encrypted sockets (to allow for distributed control)
can be achieved with only minor changes to the code base.

The messaging protocol is not decided yet, but it will be open. This will allow for third parties to easily
write other frontends, or log collectors.

\subsubsection{Logging and alarms}
All output of the services will be redirected back to \texttt{utlosed} which will both write to a rotating log
(configurable) and broadcast. The channel will be configurable, but the default will be: \texttt{logs/hostname/service}.
This means that any logging client can filter for logs, logs from a specific host, and logs from a specific service on a specific
host.

Logs written to \texttt{stderr} (and crash reports detected by \texttt{utlosed}) will also be reported on \texttt{alarms/hostname/service}
allowing for a service to listen specifically for things that are going wrong.

All logs currently held on disk may be requested via the request responce socket interface. This allows remote clients to both
respond live events happening (via subscription), but doesn't have to be running 100\% of the time to get a full history.

\subsubsection{Configuration}
Configuration is split into three parts:
\begin{enumerate}
  \item Configuration of \texttt{utlosed}
  \item Configuration of \texttt{utloseadm}
  \item Configuration of the services.
\end{enumerate}

Configuration of the first two will be found in \texttt{/etc/utlose}, but service configuration can be split
accross locations. This is to appease some package managers, which like to place everything in \texttt{/usr}

By default, \texttt{utloseadm} will assume that it is monitoring a local instance of utlose. This can be changed
by adding hosts to \texttt{/etc/utlose/utloseadm.toml}.

The config for \texttt{utlosed} will be stored in \texttt{/etc/utlose/utlosed.toml}, and will be used to turn on or off features,
change time outs and specify where the service files are located. This will also be where the default \textit{rule} is specified.

There are a few approaches to service management config that could be appropriate. I imagine that a few will be supported and
the one used will be configured in \texttt{/etc/utlose/utlosed.toml}

\begin{itemize}
  \item{Subvolume based upgrades: File Systems such as ZFS and BTRFS support snapshots of subvolumes. In this option, a snapshot is created
    every time utløse successfully loads a new complete service configuration. If it fails, it goes through the snapshots until it finds one that
    works.}
  \item{Different locations: In this option, the package manager submits changes to Utløse which are accepted or rejected. The mechanism here would be
    that the package manager puts a service file in some pre-agreed location and calls a subcommand of \texttt{utloseadm} to query the new service.
    The query can be simple, such as ``Is this well formed?'' But more complicated queries can also be supported. If all the queries pass, the new service
    files are included. If not, they are rejected and the package manager warned.}
  \item{Nothing special: Keep it simple stupid! One location for service files.}
\end{itemize}

\subsection{Configuration Language}
\subsection{Service Management Tool}

\setlength{\baselineskip}{0pt} % JEM: Single-space References

{\renewcommand*\MakeUppercase[1]{#1}%
\printbibliography[heading=bibintoc,title={\bibtitle}]}

\end{document}
